__author__ = "Roberto Medina"
__copyright__ = "Copyright 2021, Roberto Carlos Medina"
__version__ = "0.0.1"
__maintainer__ = "Roberto Medina"
__email__ = "robertocarlosmedina.dev@gmail.com "
__status__ = "Production"

"""
    This is the class where all the game loop is controlled, and where all the action are
    controlled. And also all the cubes generated by the Cube class are controlled by here.
"""

import time
import pygame
from src.support.font import Game_fonts as fonts
from src.support.colors import Game_color as color
from src.support.auxiliar_functions import write_from_file, get_screen_text
from src.game_components.disk import Disk
from src.game_components.selfplay import AI_play

class Game_loop:
    
    game_events: pygame.event        # Hold the current games events
    mouse_position: tuple            # To store and refresh the mouse position
    
    def __init__(self, game_obj: object) -> None:
        self.game_obj = game_obj
        self.board_size = (600, 20)
        self.n = self.game_obj.nr_disk
        self.disk_scale = 25
        self.disk_higth = 20
        self.pegs_gaps = 200
        self.selector_pos = 0
        self.play_pos = None
        self.moves = 0
        self.pekers_arrows = []
        self.list_moves = []
        self.play_arrows = []
        self.peg_position = (
            self.game_obj.screen_size[0]/2 - self.board_size[0]/2 + self.pegs_gaps/2.1, 
            self.game_obj.screen_size[1]/2 - self.board_size[1]/2 + 50
        )
        
        self.peg_and_disk = [set([i+1 for i in range(self.n)]), set(), set()]
        self.time_1 = time.time()
        self.make_selector_arrows()
        self.make_play_arrows()
        self.game_mode_check()
    
    def page_tittles(self) -> None:
        font_size = pygame.font.Font.size(fonts.montserrat_size_30.value, get_screen_text("game_tittle"))
        line = fonts.montserrat_size_30.value.render(get_screen_text("game_tittle"), True, color.brown.value)
        self.game_obj.screen.blit(line, (self.game_obj.screen_size[0]/2-(font_size[0]/2), 20))

    def game_mode_check(self) -> None:
        if (self.game_obj.game_mode == "game_ai_play"):
            ai_moves = AI_play(self.n)
            self.list_moves = ai_moves.get_all_moves()

    def make_selector_arrows(self) -> None:
        x = int(self.peg_position[0]) - 10
        y = int(self.peg_position[1]) + 105
        for _ in range(3):
            self.pekers_arrows.append(((x, y - 20), \
                (x + 15, y - 30), (x + 30, y - 20)))
            x += self.pegs_gaps
    
    def make_play_arrows(self) -> None:
        x = int(self.peg_position[0]) - 10
        y = int(self.peg_position[1]) - 180
        for _ in range(3):
            self.play_arrows.append(((x, y - 20), \
                (x + 15, y - 10), (x + 30, y - 20)))
            x += self.pegs_gaps
    
    def selector(self) -> int:
        count = 0
        for index, arrow in enumerate(self.pekers_arrows):
            if self.peg_and_disk[index]:
                if (self.mouse_position[0]in range(arrow[0][0], arrow[2][0]) and (self.mouse_position[1]in range(arrow[0][1], arrow[1][1])or\
                    self.mouse_position[1]in range(arrow[1][1], arrow[0][1]))): # checking if mouse is over them to draw them whit defferent color
                    # checking if the mouse is pressed to change the slide page
                    if pygame.mouse.get_pressed()[0]:
                        pygame.draw.polygon(self.game_obj.screen, color.grey_1.value, arrow)
                        pygame.draw.polygon(self.game_obj.screen, color.black.value, arrow, 3)
                        self.selector_pos =  count + 1
                        # check if it is not in the last page to increment the page
                    else:
                        pygame.draw.polygon(self.game_obj.screen, color.grey.value, arrow)
                        pygame.draw.polygon(self.game_obj.screen, color.grey.value, arrow, 3)
                else:
                    pygame.draw.polygon(self.game_obj.screen, color.grey.value, arrow)
                    pygame.draw.polygon(self.game_obj.screen, color.white.value, arrow, 3)
            count += 1
    
    def change_disk_position(self, destination_place: int) -> None:
        move_value = list(self.peg_and_disk[self.selector_pos - 1])[0]
        self.peg_and_disk[self.selector_pos - 1].remove(move_value)
        new_animation = Disk(self.game_obj)

        new_animation.draw_disk_animation(
            self.pekers_arrows[destination_place][1],
            self.game_obj.screen_size[1]/2 - self.board_size[1]/2 + 90 - \
                len(list(self.peg_and_disk[destination_place])) * self.disk_higth + 2, 
            self.draw_board, 
            self.draw_disks,
            self.page_tittles, 
            self.disk_scale, 
            move_value,
        )
        self.peg_and_disk[destination_place].add(move_value)
        self.selector_pos = 0
        self.moves += 1

    def available_peg(self, peg_index: int) -> bool:
        if not self.peg_and_disk[peg_index]:
            return True
        else:
            if list(self.peg_and_disk[peg_index])[0] > list(self.peg_and_disk[self.selector_pos - 1])[0]:
                return True

        return False

    def make_play(self) -> None:
        count = 0
        for index, arrow in enumerate(self.play_arrows):
            if index != self.selector_pos - 1 and self.available_peg(index):
                if (self.mouse_position[0]in range(arrow[0][0], arrow[2][0]) and (self.mouse_position[1]in range(arrow[0][1], arrow[1][1])or\
                    self.mouse_position[1]in range(arrow[1][1], arrow[0][1]))): # checking if mouse is over them to draw them whit defferent color
                    # checking if the mouse is pressed to change the slide page
                    if pygame.mouse.get_pressed()[0]:
                        pygame.draw.polygon(self.game_obj.screen, color.grey_1.value, arrow)
                        pygame.draw.polygon(self.game_obj.screen, color.black.value, arrow, 3)
                        self.change_disk_position(count)
                        break
                        # check if it is not in the last page to increment the page
                    else:
                        pygame.draw.polygon(self.game_obj.screen, color.grey.value, arrow)
                        pygame.draw.polygon(self.game_obj.screen, color.grey.value, arrow, 3)
                else:
                    pygame.draw.polygon(self.game_obj.screen, color.grey.value, arrow)
                    pygame.draw.polygon(self.game_obj.screen, color.white.value, arrow, 3)
            count += 1

    def game_over(self, game_result: bool) -> None:
        time_2 = time.time()
        time_interval = time_2 - self.time_1
        write_from_file("./data/end_game_values.txt", "w", f"{int(game_result)} {self.moves} {str(time_interval)[0:5]}")
        self.game_obj.current_link = "game_over"

    def draw_board(self) -> None:
        x = self.peg_position[0]
        for _ in self.peg_and_disk:
            pygame.draw.rect(
            self.game_obj.screen, 
            color.grey.value, pygame.Rect(
                x, 
                self.game_obj.screen_size[1]/2 - self.board_size[1]/2 - 75, 
                12, 
                170), 
                border_radius = 10
            ) 
            x += self.pegs_gaps

        pygame.draw.rect(
            self.game_obj.screen, 
            color.brown_1.value, pygame.Rect(
                self.game_obj.screen_size[0]/2 - self.board_size[0]/2, 
                self.game_obj.screen_size[1]/2 - self.board_size[1]/2 + 90, 
                self.board_size[0], 
                self.board_size[1]
            ), 
            border_radius = 5,
        )
        pygame.draw.rect(
            self.game_obj.screen, 
            color.brown.value, pygame.Rect(
                self.game_obj.screen_size[0]/2 - self.board_size[0]/2, 
                self.game_obj.screen_size[1]/2 - self.board_size[1]/2 + 90, 
                self.board_size[0], 
                self.board_size[1]
            ), 
            1,
            border_radius = 5,
        )
        
    def draw_disks(self) -> None:
        x = self.peg_position[0] + 6
        y = self.game_obj.screen_size[1]/2 - self.board_size[1]/2 + 69
        for index, disk_set in enumerate(self.peg_and_disk):
            border_color = color.white_3.value
            if index  == self.selector_pos - 1:
                border_color = color.white_1.value

            for disk in list(disk_set)[::-1]:
                disk_size = disk * self.disk_scale
                pygame.draw.rect(
                    self.game_obj.screen, 
                    color.brown.value, pygame.Rect(
                        x - disk_size/2, 
                        y, 
                        disk_size, 
                        self.disk_higth
                    ), 
                    border_radius = 3,
                )
                pygame.draw.rect(
                    self.game_obj.screen, 
                    border_color, pygame.Rect(
                        x - disk_size/2, 
                        y, 
                        disk_size, 
                        self.disk_higth
                    ), 
                    1,
                    border_radius = 3,
                )
                y -= self.disk_higth + 1
            y = self.game_obj.screen_size[1]/2 - self.board_size[1]/2 + 69
            x += self.pegs_gaps

    def draw_game_info(self) -> None:
        font_size = pygame.font.Font.size(fonts.montserrat_size_18.value, f"Moves: {self.moves}")
        line = fonts.montserrat_size_18.value.render(f"Moves: {self.moves}", True, color.white.value)
        self.game_obj.screen.blit(line, (self.game_obj.screen_size[0]/2-(font_size[0]/2), 400))

        time_2 = time.time()
        time_interval = time_2 - self.time_1
        font_size = pygame.font.Font.size(fonts.montserrat_size_18.value, f"Timer: ")
        line = fonts.montserrat_size_18.value.render(f"Timer: ", True, color.white.value)
        self.game_obj.screen.blit(line, (self.game_obj.screen_size[0]/2-(font_size[0]/2) - 50, 430))

        font_size = pygame.font.Font.size(fonts.montserrat_size_18.value, f"{str(time_interval)[0:5]}")
        line = fonts.montserrat_size_18.value.render(f"{str(time_interval)[0:5]}", True, color.white.value)
        self.game_obj.screen.blit(line, (self.game_obj.screen_size[0]/2-(font_size[0]/2) + 50, 430))

        font_size = pygame.font.Font.size(fonts.montserrat_size_14.value, 'Press  "e"  to exit selector mode')
        line = fonts.montserrat_size_14.value.render('Press  "e"  to exit selector mode', True, color.red.value)
        self.game_obj.screen.blit(line, (self.game_obj.screen_size[0]/2-(font_size[0]/2), 470))

    def check_game_over(self) -> bool:
        return self.peg_and_disk == [set(), set(), set([i + 1 for i in range(self.n)])]

    def run_link(self) -> None:
        change_page_by_action = change_page_by_event = False

        while True:
            self.game_obj.screen_fill_bg()
            self.mouse_position = pygame.mouse.get_pos()

            self.page_tittles()
            if pygame.key.get_pressed()[pygame.K_e]:
                self.selector_pos = 0

            change_page_by_event = self.game_obj.game_events_handler()
            self.draw_board()
            self.draw_disks()
            if(self.game_obj.game_mode == "game_ai_play"):
                for change in self.list_moves:
                    self.selector_pos = change[0] + 1
                    if not self.check_game_over:
                        break
                    self.change_disk_position(change[1])
            else:
                self.selector() if not self.selector_pos else self.make_play()

            if not self.check_game_over:
                change_page_by_action = True
                self.game_over(True)
            
            self.draw_game_info()

            if change_page_by_action or change_page_by_event:
                break

            pygame.display.update()
