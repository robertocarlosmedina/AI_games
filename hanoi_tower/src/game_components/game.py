__author__ = "Roberto Medina"
__copyright__ = "Copyright 2021, Roberto Carlos Medina"
__version__ = "0.0.1"
__maintainer__ = "Roberto Medina"
__email__ = "robertocarlosmedina.dev@gmail.com "
__status__ = "Production"

"""
    This is the class where all the game loop is controlled, and where all the action are
    controlled. And also all the cubes generated by the Cube class are controlled by here.
"""

import time
import pygame
from src.support.font import Game_fonts as fonts
from src.support.colors import Game_color as color
from src.support.auxiliar_functions import write_from_file, get_screen_text
from src.game_components.disk import Disk
from src.self_play.selfplay import AI_play

class Game_loop:
    
    game_events: pygame.event        # Hold the current games events
    mouse_position: tuple            # To store and refresh the mouse position
    disk_higth: int                  # the value of the disk height
    disk_scale: int                  # Scale to help drawing the disk's
    pegs_gaps: int                   # distance between the pegs
    board_size: tuple                # Hanoi board info (size's)
    n: int                           # number of disk's
    selector_pos: int                # Store the value selected by the selector's
    list_moves: list                 # store all the moves made by the AI agent
    pekers_arrows: list              # Store all the selector arrow peker's position
    play_arrows: list                # Store all the player move arrow's position
    peg_position: tuple              # store the first peg positon
    peg_and_disk: list               # Store a list of set's according the to number of peg's and disk's
    timer_1: time.time               # Store the initial time
    
    def __init__(self, game_obj: object) -> None:
        self.game_obj = game_obj
        self.board_size = (600, 20)
        self.n = self.game_obj.nr_disk
        self.disk_scale = 25
        self.disk_higth = 20
        self.pegs_gaps = 200
        self.selector_pos = 0
        self.play_pos = None
        self.moves = 0
        self.pekers_arrows = []
        self.list_moves = []
        self.play_arrows = []
        self.peg_position = (
            self.game_obj.screen_size[0]/2 - self.board_size[0]/2 + self.pegs_gaps/2.1, 
            self.game_obj.screen_size[1]/2 - self.board_size[1]/2 + 50
        )
        self.peg_and_disk = [set([i+1 for i in range(self.n)]), set(), set()]
        self.time_1 = time.time()
        self.make_selector_arrows()
        self.make_play_arrows()
        self.game_mode_check()
    
    def page_tittles(self) -> None:
        """
            Draw the tittle header.
        """
        font_size = pygame.font.Font.size(fonts.montserrat_size_30.value, get_screen_text("game_tittle"))
        line = fonts.montserrat_size_30.value.render(get_screen_text("game_tittle"), True, color.brown.value)
        self.game_obj.screen.blit(line, (self.game_obj.screen_size[0]/2-(font_size[0]/2), 20))

    def game_mode_check(self) -> None:
        """
            Method that check the game mode, and if it is an AI agent
            it makes a list of the steps to complete the towers on the final goal test.
        """
        if (self.game_obj.game_mode == "game_ai_play"):
            ai_moves = AI_play(self.n)
            self.list_moves = ai_moves.get_all_moves()

    def make_selector_arrows(self) -> None:
        """
            Method that make the calcum of the selector arrows
        """
        x = int(self.peg_position[0]) - 10
        y = int(self.peg_position[1]) + 105
        for _ in range(3):
            self.pekers_arrows.append(((x, y - 20), \
                (x + 15, y - 30), (x + 30, y - 20)))
            x += self.pegs_gaps
    
    def make_play_arrows(self) -> None:
        """
            Method that make the calcum of the player arrows
        """
        x = int(self.peg_position[0]) - 10
        y = int(self.peg_position[1]) - 180
        for _ in range(3):
            self.play_arrows.append(((x, y - 20), \
                (x + 15, y - 10), (x + 30, y - 20)))
            x += self.pegs_gaps
    
    def selector(self) -> int:
        """
            This allow's the player to chose in witch peg he wants to change.
        """
        count = 0
        for index, arrow in enumerate(self.pekers_arrows):
            if self.peg_and_disk[index]:
                if (self.mouse_position[0]in range(arrow[0][0], arrow[2][0]) and (self.mouse_position[1]in range(arrow[0][1], arrow[1][1])or\
                    self.mouse_position[1]in range(arrow[1][1], arrow[0][1]))): # checking if mouse is over them to draw them whit defferent color
                    # checking if the mouse is pressed to change the slide page
                    if pygame.mouse.get_pressed()[0]:
                        pygame.draw.polygon(self.game_obj.screen, color.grey_1.value, arrow)
                        pygame.draw.polygon(self.game_obj.screen, color.black.value, arrow, 3)
                        self.selector_pos =  count + 1
                        # check if it is not in the last page to increment the page
                    else:
                        pygame.draw.polygon(self.game_obj.screen, color.grey.value, arrow)
                        pygame.draw.polygon(self.game_obj.screen, color.grey.value, arrow, 3)
                else:
                    pygame.draw.polygon(self.game_obj.screen, color.grey.value, arrow)
                    pygame.draw.polygon(self.game_obj.screen, color.white.value, arrow, 3)
            count += 1
    
    def change_disk_position(self, destination_place: int) -> None:
        """
            This make the move chosen by the agent and then call the animation
            class to make the disk animation.
        """
        move_value = list(self.peg_and_disk[self.selector_pos - 1])[0]
        self.peg_and_disk[self.selector_pos - 1].remove(move_value)
        new_animation = Disk(self.game_obj)

        new_animation.draw_disk_animation(
            self.pekers_arrows[destination_place][1],
            self.game_obj.screen_size[1]/2 - self.board_size[1]/2 + 66 - \
                len(list(self.peg_and_disk[destination_place])) * self.disk_higth + 2, 
            self.draw_board, 
            self.draw_disks,
            self.page_tittles, 
            self.disk_scale, 
            move_value,
        )
        self.peg_and_disk[destination_place].add(move_value)
        self.selector_pos = 0
        self.moves += 1

    def available_peg(self, peg_index: int) -> bool:
        """
            Check if the player can play in a peg that was a disk bigger than the 
            one that the player wants to play.
        """
        if not self.peg_and_disk[peg_index]:
            return True
        else:
            if list(self.peg_and_disk[peg_index])[0] > list(self.peg_and_disk[self.selector_pos - 1])[0]:
                return True

        return False

    def make_play(self) -> None:
        """
            Method that control the playr move by the mouse.
        """
        count = 0
        for index, arrow in enumerate(self.play_arrows):
            if index != self.selector_pos - 1 and self.available_peg(index):
                if (self.mouse_position[0]in range(arrow[0][0], arrow[2][0]) and (self.mouse_position[1]in range(arrow[0][1], arrow[1][1])or\
                    self.mouse_position[1]in range(arrow[1][1], arrow[0][1]))): # checking if mouse is over them to draw them whit defferent color
                    # checking if the mouse is pressed to change the slide page
                    if pygame.mouse.get_pressed()[0]:
                        pygame.draw.polygon(self.game_obj.screen, color.grey_1.value, arrow)
                        pygame.draw.polygon(self.game_obj.screen, color.black.value, arrow, 3)
                        self.change_disk_position(count)
                        break
                        # check if it is not in the last page to increment the page
                    else:
                        pygame.draw.polygon(self.game_obj.screen, color.grey.value, arrow)
                        pygame.draw.polygon(self.game_obj.screen, color.grey.value, arrow, 3)
                else:
                    pygame.draw.polygon(self.game_obj.screen, color.grey.value, arrow)
                    pygame.draw.polygon(self.game_obj.screen, color.white.value, arrow, 3)
            count += 1

    def game_over(self, game_result: bool) -> None:
        """
            Method to store the game results in a file and also change the current game link.
        """
        time_2 = time.time()
        time_interval = time_2 - self.time_1
        write_from_file("./data/end_game_values.txt", "w", f"{int(game_result)} {self.moves} {str(time_interval)[0:5]}")
        self.game_obj.current_link = "game_over"

    def draw_board(self) -> None:
        """
            Method to draw the board on the screen.
        """
        x = self.peg_position[0]
        for _ in self.peg_and_disk:
            pygame.draw.rect(
            self.game_obj.screen, 
            color.grey.value, pygame.Rect(
                x, 
                self.game_obj.screen_size[1]/2 - self.board_size[1]/2 - 75, 
                12, 
                170), 
                border_radius = 10
            ) 
            x += self.pegs_gaps

        pygame.draw.rect(
            self.game_obj.screen, 
            color.brown_1.value, pygame.Rect(
                self.game_obj.screen_size[0]/2 - self.board_size[0]/2, 
                self.game_obj.screen_size[1]/2 - self.board_size[1]/2 + 90, 
                self.board_size[0], 
                self.board_size[1]
            ), 
            border_radius = 5,
        )
        pygame.draw.rect(
            self.game_obj.screen, 
            color.brown.value, pygame.Rect(
                self.game_obj.screen_size[0]/2 - self.board_size[0]/2, 
                self.game_obj.screen_size[1]/2 - self.board_size[1]/2 + 90, 
                self.board_size[0], 
                self.board_size[1]
            ), 
            1,
            border_radius = 5,
        )
        
    def draw_disks(self) -> None:
        """
            Method to draw all the disk according to their state.
        """
        x = self.peg_position[0] + 6
        y = self.game_obj.screen_size[1]/2 - self.board_size[1]/2 + 69
        for index, disk_set in enumerate(self.peg_and_disk):
            border_color = color.white_3.value
            if index  == self.selector_pos - 1:
                border_color = color.white_1.value

            for disk in list(disk_set)[::-1]:
                disk_size = disk * self.disk_scale
                pygame.draw.rect(
                    self.game_obj.screen, 
                    color.brown.value, pygame.Rect(
                        x - disk_size/2, 
                        y, 
                        disk_size, 
                        self.disk_higth
                    ), 
                    border_radius = 3,
                )
                pygame.draw.rect(
                    self.game_obj.screen, 
                    border_color, pygame.Rect(
                        x - disk_size/2, 
                        y, 
                        disk_size, 
                        self.disk_higth
                    ), 
                    1,
                    border_radius = 3,
                )
                y -= self.disk_higth + 1
            y = self.game_obj.screen_size[1]/2 - self.board_size[1]/2 + 69
            x += self.pegs_gaps

    def draw_game_info(self) -> None:
        """
            Method to draw all the game info on the screen.
        """
        font_size = pygame.font.Font.size(fonts.montserrat_size_18.value, f"Moves: {self.moves}")
        line = fonts.montserrat_size_18.value.render(f"Moves: {self.moves}", True, color.white.value)
        self.game_obj.screen.blit(line, (self.game_obj.screen_size[0]/2-(font_size[0]/2), 400))

        time_2 = time.time()
        time_interval = time_2 - self.time_1
        font_size = pygame.font.Font.size(fonts.montserrat_size_18.value, f"Timer: ")
        line = fonts.montserrat_size_18.value.render(f"Timer: ", True, color.white.value)
        self.game_obj.screen.blit(line, (self.game_obj.screen_size[0]/2-(font_size[0]/2) - 50, 430))

        font_size = pygame.font.Font.size(fonts.montserrat_size_18.value, f"{str(time_interval)[0:5]}")
        line = fonts.montserrat_size_18.value.render(f"{str(time_interval)[0:5]}", True, color.white.value)
        self.game_obj.screen.blit(line, (self.game_obj.screen_size[0]/2-(font_size[0]/2) + 50, 430))

        font_size = pygame.font.Font.size(fonts.montserrat_size_14.value, 'Press  "e"  to exit selector mode')
        line = fonts.montserrat_size_14.value.render('Press  "e"  to exit selector mode', True, color.red.value)
        self.game_obj.screen.blit(line, (self.game_obj.screen_size[0]/2-(font_size[0]/2), 470))

    def run_link(self) -> None:
        """
            The main loop of the game page.
        """
        change_page_by_action = change_page_by_event = False

        while True:
            self.game_obj.screen_fill_bg()
            self.mouse_position = pygame.mouse.get_pos()

            self.page_tittles()
            if pygame.key.get_pressed()[pygame.K_e]:
                self.selector_pos = 0

            change_page_by_event = self.game_obj.game_events_handler()
            self.draw_board()
            self.draw_disks()
            if(self.game_obj.game_mode == "game_ai_play"):
                """
                    If it is an AI player. Then if must make the change one by one that 
                    has been already provided.
                """
                for change in self.list_moves:
                    self.selector_pos = change[0] + 1
                    if self.peg_and_disk == [set(), set(), set([i + 1 for i in range(self.n)])]:
                        break
                    self.change_disk_position(change[1])
            else:
                self.selector() if not self.selector_pos else self.make_play()

            if self.peg_and_disk == [set(), set(), set([i + 1 for i in range(self.n)])]:
                change_page_by_action = True
                self.game_over(True)
            
            self.draw_game_info()

            if change_page_by_action or change_page_by_event:
                break

            pygame.display.update()
        time.sleep(1)
